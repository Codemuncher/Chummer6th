<#@ template debug="false" hostspecific="true" language="C#" #><#@ output extension=".cs" #><#@ import namespace="System.IO" #><#@ import namespace="System.Collections.Generic" #><#@ import namespace="EnvDTE" #>/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */

using System;
using System.Xml;
using System.Threading;
using System.Threading.Tasks;
// ReSharper disable StringLiteralTypo

// This file is automatically generated from the T4 template ImprovementMethods.tt
// It is NOT, I repeat NOT, meant to be edited manually.
// If you wish to modify this file, please do so instead by modifying the template and re-running it.

namespace Chummer
{
    public static class ImprovementMethods
    {
        /// <summary>
        /// Gets an AddImprovementCollection function based on its name.
        /// </summary>
        /// <param name="strMethodName">Name of the function, in all uppercase.</param>
        /// <param name="objImprovementAdder">Container for the function (since they're not static, we need a container).</param>
        /// <returns>Function pointer to the named function if one is found. If none are found, returns a null pointer.</returns>
        public static Action<XmlNode> GetMethod(string strMethodName, [Annotations.NotNull] AddImprovementCollection objImprovementAdder)
        {
            if (objImprovementAdder == null)
                throw new ArgumentNullException(nameof(objImprovementAdder));
            // Switch-cases get compiled as hashes, so this is as close as you can get to a compile-time Dictionary
            switch (strMethodName)
            {
<#
        EnvDTE.DTE dte = (EnvDTE.DTE) ((IServiceProvider) this.Host).GetService(typeof(EnvDTE.DTE));

        // Modus operandi is to take the .cs file containing all the methods we want, parse it line-by-line, and each time we find a method name, we add it to a list of method names.
        // Once we have all the method names, we construct a giant switch-case block that functions as a static Dictionary for AddImprovementCollection methods.
        // The main reason for this is performance, ease of debugging, and making code easier to read, none of which applied to the older method that relied on reflection.
        // Having to re-run this template is a small price to pay compared to what is gained from having this much more straightforward structure.

        List<string> lststrSyncMethodNames = new List<string>();
        List<string> lststrStaticSyncMethodNames = new List<string>();
        string strAddImprovementCollectionFilePath = System.IO.Path.Combine(dte.ActiveDocument.Path, "AddImprovementCollection.cs");
        if (File.Exists(strAddImprovementCollectionFilePath))
        {
            StreamReader objReader = File.OpenText(strAddImprovementCollectionFilePath);
            string strLine;
            while ((strLine = objReader.ReadLine()) != null)
            {
                // Trim away the newlines and empty spaces at the beginning and end of lines
                strLine = strLine.Trim('\n', '\r', ' ').Trim();

                // Check if this line contains a method name. This is kind of hacky, as it relies on every improvement method using "(XmlNode bonusNode)" as its argument
                const string strSuffix = "(XmlNode bonusNode)";
                if (strLine.EndsWith(strSuffix))
                {
                    if (strLine.StartsWith("public void "))
                        lststrSyncMethodNames.Add(strLine.Substring(("public void ").Length, strLine.Length - ("public void ").Length - (strSuffix).Length));
                    else if (strLine.StartsWith("public async void "))
                        lststrSyncMethodNames.Add(strLine.Substring(("public async void ").Length, strLine.Length - ("public async void ").Length - (strSuffix).Length));
                    else if (strLine.StartsWith("public static void "))
                        lststrStaticSyncMethodNames.Add(strLine.Substring(("public static void ").Length, strLine.Length - ("public static void ").Length - (strSuffix).Length));
                    else if (strLine.StartsWith("public static async void "))
                        lststrStaticSyncMethodNames.Add(strLine.Substring(("public static async void ").Length, strLine.Length - ("public static async void ").Length - (strSuffix).Length));
                }
            }
            // Now we add cases for each method, and each case returns a pointer to the function that we're looking for
            foreach (string strMethodName in lststrSyncMethodNames)
            {
#>
                case "<#= strMethodName.ToUpperInvariant() #>":
                    return objImprovementAdder.<#= strMethodName #>;
<#
            }
            foreach (string strMethodName in lststrStaticSyncMethodNames)
            {
#>
                case "<#= strMethodName.ToUpperInvariant() #>":
                    return AddImprovementCollection.<#= strMethodName #>;
<#
            }
#>
                // No method matches, return a null pointer
                default:
                    return null;
            }
<#
        }
        else
        {
#>
                // No file found, return a null pointer
                default:
                    return null;
            }
<#
        }
#>
        }

        /// <summary>
        /// Gets an AddImprovementAsyncCollection function based on its name.
        /// </summary>
        /// <param name="strMethodName">Name of the function, in all uppercase.</param>
        /// <param name="objImprovementAsyncAdder">Container for the function (since they're not static, we need a container).</param>
        /// <returns>Function pointer to the named function if one is found. If none are found, returns a null pointer.</returns>
        public static Func<XmlNode, CancellationToken, Task> GetAsyncMethod(string strMethodName, [Annotations.NotNull] AddImprovementAsyncCollection objImprovementAsyncAdder)
        {
            if (objImprovementAsyncAdder == null)
                throw new ArgumentNullException(nameof(objImprovementAsyncAdder));
            // Switch-cases get compiled as hashes, so this is as close as you can get to a compile-time Dictionary
            switch (strMethodName)
            {
<#
        // Modus operandi is to take the .cs file containing all the methods we want, parse it line-by-line, and each time we find a method name, we add it to a list of method names.
        // Once we have all the method names, we construct a giant switch-case block that functions as a static Dictionary for AddImprovementAsyncCollection methods.
        // The main reason for this is performance, ease of debugging, and making code easier to read, none of which applied to the older method that relied on reflection.
        // Having to re-run this template is a small price to pay compared to what is gained from having this much more straightforward structure.

        List<string> lststrAsyncMethodNames = new List<string>();
        List<string> lststrStaticAsyncMethodNames = new List<string>();
        string strAddImprovementAsyncCollectionFilePath = System.IO.Path.Combine(dte.ActiveDocument.Path, "AddImprovementAsyncCollection.cs");
        if (File.Exists(strAddImprovementAsyncCollectionFilePath))
        {
            StreamReader objReader = File.OpenText(strAddImprovementAsyncCollectionFilePath);
            string strLine;
            while ((strLine = objReader.ReadLine()) != null)
            {
                // Trim away the newlines and empty spaces at the beginning and end of lines
                strLine = strLine.Trim('\n', '\r', ' ').Trim();

                // Check if this line contains a method name. This is kind of hacky, as it relies on every improvement method using "(XmlNode bonusNode)" as its argument
                const string strSuffix = "(XmlNode bonusNode, CancellationToken token = default)";
                if (strLine.EndsWith(strSuffix))
                {
                    if (strLine.StartsWith("public Task "))
                        lststrAsyncMethodNames.Add(strLine.Substring(("public Task ").Length, strLine.Length - ("public Task ").Length - (strSuffix).Length));
                    else if (strLine.StartsWith("public async Task "))
                        lststrAsyncMethodNames.Add(strLine.Substring(("public async Task ").Length, strLine.Length - ("public async Task ").Length - (strSuffix).Length));
                    else if (strLine.StartsWith("public static Task "))
                        lststrStaticAsyncMethodNames.Add(strLine.Substring(("public static Task ").Length, strLine.Length - ("public static Task ").Length - (strSuffix).Length));
                    else if (strLine.StartsWith("public static async Task "))
                        lststrStaticAsyncMethodNames.Add(strLine.Substring(("public static async Task ").Length, strLine.Length - ("public static async Task ").Length - (strSuffix).Length));
                }
            }

            // Now we add cases for each method, and each case returns a pointer to the function that we're looking for
            foreach (string strMethodName in lststrAsyncMethodNames)
            {
#>
                case "<#= strMethodName.ToUpperInvariant() #>":
                    return objImprovementAsyncAdder.<#= strMethodName #>;
<#
            }
            // Now we add cases for each method, and each case returns a pointer to the function that we're looking for
            foreach (string strMethodName in lststrStaticAsyncMethodNames)
            {
#>
                case "<#= strMethodName.ToUpperInvariant() #>":
                    return AddImprovementAsyncCollection.<#= strMethodName #>;
<#
            }
#>
                // No method matches, return a null pointer
                default:
                    return null;
            }
<#
        }
        else
        {
#>
                // No file found, return a null pointer
                default:
                    return null;
            }
<#
        }

        if (lststrSyncMethodNames.Count > 0 || lststrAsyncMethodNames.Count > 0)
        {
            bool blnFoundMatch;
            foreach (string strAsyncMethodName in lststrAsyncMethodNames)
            {
                blnFoundMatch = false;
                foreach (string strSyncMethodName in lststrSyncMethodNames)
                {
                    if (strAsyncMethodName == strSyncMethodName)
                    {
                        blnFoundMatch = true;
                        break;
                    }
                }
                if (blnFoundMatch)
                {
                    lststrSyncMethodNames.Remove(strAsyncMethodName);
                }
                else
                {
#>
#error Asynchronous improvement adder is missing synchronous version: <#= strAsyncMethodName #>. Please add one to AddImprovementCollection.cs.
<#
                }
            }
            foreach (string strSyncMethodName in lststrSyncMethodNames)
            {
#>
#error Synchronous improvement adder is missing asynchronous version: <#= strSyncMethodName #>. Please add one to AddImprovementAsyncCollection.cs.
<#
            }
        }
        if (lststrStaticSyncMethodNames.Count > 0 || lststrStaticAsyncMethodNames.Count > 0)
        {
            bool blnFoundMatch;
            foreach (string strAsyncMethodName in lststrStaticAsyncMethodNames)
            {
                blnFoundMatch = false;
                foreach (string strSyncMethodName in lststrStaticSyncMethodNames)
                {
                    if (strAsyncMethodName == strSyncMethodName)
                    {
                        blnFoundMatch = true;
                        break;
                    }
                }
                if (blnFoundMatch)
                {
                    lststrStaticSyncMethodNames.Remove(strAsyncMethodName);
                }
                else
                {
#>
#error Static asynchronous improvement adder is missing static synchronous version: <#= strAsyncMethodName #>. Please add one to AddImprovementCollection.cs.
<#
                }
            }
            foreach (string strSyncMethodName in lststrStaticSyncMethodNames)
            {
#>
#error Static synchronous improvement adder is missing static asynchronous version: <#= strSyncMethodName #>. Please add one to AddImprovementAsyncCollection.cs.
<#
            }
        }
#>
        }
    }
}
